{\rtf0\pc\deff5709{\fonttbl{\f5709\fnil Bitstream Charter Black;}{\f5648\fnil Bitstream Charter;}{\f5649\fnil Bitstream Charter Italic;}}\nofpages13\deftab720\paperw11520\paperh15264\margl1440\margr1440\margt1440\margb1440\pgnstart1\pgndec\sectd\cols1\headery720\footery720 \pard\ql\fi0\li0\ri731\plain\f5709\fs36 \tab \tab \tab \tab \tab \tab \tab \tab \tab \f5648\fs24 2/16/95\par\pard\ql\fi0\li0\ri731\plain\f5649\fs36 PRELIMINARY SPECIFICATION: FOR REVIEW PURPOSES ONLY\par\pard\ql\fi0\li0\ri731\plain\f5649\fs36 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs36 Non Volatile Memory - Bios calls\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 These calls are provided to allow developers to save game information into non-volatile memory in an efficient and easy to use manner.  There will be 128K bytes available in NV memory in the first version of the hardware (later cartridges may include more or less memory, so developers should use the Inquire function to determine the actual space available).  This memory will be used and allocated in a file system like manner, so that multiple games may use the same non-volatile memory cartridge without conflict, and so that different cartridge sizes may easily be supported. The NVM_Bios calls are thus much like the GEMDOS or MS-DOS file system calls.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 Every cartridge contains a 4K table of contents and file allocation table (FAT), leaving 124K for data. This 124K of data may be used for up to 199 memory blocks (i.e. there is space in the table of contents for 199 directory entries). The length of each block of memory is some multiple of 512 bytes.  Memory blocks must be given a size when they are created, and cannot exceed that size later. \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 A memory block is uniquely identified by 2 strings: the application which created it, and a block specific name (its "file name").  The application name is available so that users may quickly identify which applications are associated with which blocks of memory.  Both application and file names must use only characters chosen from the following 40 character set:\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab 0 1 2 3 4 5 6 7 8 9\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab : ' . space\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 Application names may be up to 15 characters in length, and file names may be up to\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 9 characters in length.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 There will be 11 bios calls provided to access NV memory.  A magic cookie with value '_NVM' will exist at address $2400, and a dispatcher for the BIOS will exist at $2404.  JSR to $2404 with the opcode and parameters described on the following pages to invoke the requested bios call.  The following is a list of the routines along with their opcodes:\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab Initialize\tab -\tab opcode 0\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab Create\tab \tab -\tab opcode 1\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab Open\tab \tab - \tab opcode 2\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab Close\tab \tab -\tab opcode 3\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab Delete\tab \tab - \tab opcode 4\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab Read\tab \tab -\tab opcode 5\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab Write\tab \tab -\tab opcode 6\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab Search First\tab - \tab opcode 7\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab Search Next\tab -\tab opcode 8\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab Seek\tab \tab -\tab opcode 9\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab Inquire\tab -\tab opcode 10\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 All of the functions return a 32 bit value in d0, although in many cases only the lower 16 bits will be of interest.  If bit 31 of d0 is set (i.e. if d0.l is negative) then an error has occured.  The following error codes are defined:\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab ENOINIT\tab -1\tab the Initialize function has not yet been called\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab ENOSPC\tab -2\tab there is not enough free space for the operation\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab EFILNF\tab -3\tab the file was not found\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab EINVFN\tab -4\tab an attempt was made to use an invalid function\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab ERANGE\tab -5\tab an attempt was made to seek out of range\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab ENFILES\tab -6\tab no more file handles are available\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab EIHNDL\tab -7\tab invalid handle passed to function\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs36 Initialize\tab \tab -\tab Opcode 0\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 int\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 NVM_Bios(0, app_name, work_area)\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\tab \f5648 int\tab \tab opcode = 0;\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 \tab \tab \tab \f5648 char\tab \tab *app_name;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab char\tab \tab *work_area;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Assembly\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\tab  \f5648 4(sp)\tab \tab 0\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab  6(sp)\tab  \tab app_name\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 \tab \tab \tab \f5648 10(sp)\tab \tab work_area\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Returns:\tab \tab \f5648 0\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Purpose:\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 Initialize must be called before any other NVM_Bios function. Its purpose is to initialize the NVM_Bios system, and also to identify the current application to the NVM Bios. The application name (a null terminated string satisfying the rules listed above) is passed as the parameter\f5649  app_name\f5648 .  All subsequent Create and Open operations will use this application name for the memory blocks being created or opened.  The second parameter (\f5649 work_area\f5648 ) must point to a 16K, phrase aligned buffer which the NVM Bios may use as a scratch buffer.  Applications need not preserve the contents of this memory between NVM_Bios calls (i.e. they can also use it for other purposes when not using the NVM Bios) but they must be aware that the buffer will be modified by all NVM_Bios calls.  In other words, you can do what you want with the 16K between NVM_Bios calls, but every time you call NVM_Bios the 16K will be trashed.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 It is legal to call Initialize more than once; indeed, this is the only way for applications to open another application's memory blocks or for an application to change the location of the 16K NVM_Bios buffer.  Please note that calling Initialize will invalidate all currently open handles (returned by Create or Open).\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 All other NVM_Bios functions will return ENOINIT if called before the first call to Initialize.\par\pard\ql\fi0\li0\ri731\plain\f5709\fs36 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs36 Create\tab \tab -\tab Opcode 1\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 int\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 NVM_Bios(1, file_name, file_size)\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\tab \f5648 int\tab \tab opcode = 1;\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 \tab \tab \tab \f5648 char\tab \tab *file_name;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab long\tab \tab file_size;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Assembly\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\tab  \f5648 4(sp)\tab \tab #1\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab  6(sp)\tab  \tab file_name\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 \tab \tab \tab \f5648 10(sp)\tab \tab file_size\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Returns:\tab \tab \f5648 A non-negative handle on success\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab ENOINIT\tab if the Initialize function has not yet been called\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab ENOSPC\tab if there is insufficient room to allocate the file\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Purpose:\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 Create should be used to allocate a specified number of bytes from backup memory.  The parameter \f5649 file_name\f5648  should point to a name for the memory block.  If the current application (specified by the Initialize call) already has a memory block with the same name, then that block will be deleted and a new one created (i.e. the new block will replace the existing one).  \f5649 File_size \f5648 should contain the size in bytes required for the block. This size will be rounded up to the nearest multiple of 256 before being used for allocation.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 Note that multiple applications may have files with the same name, without affecting one another; Create will only delete an existing file if both the file name AND the application name match.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 The file handle returned by Create must be used in any Read, Write, or Seek calls referring to this file.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 WARNING:  do not make this call if there is an existing file handle (returned by a previous Create or Open call) referring to a file with the same name as the new file being created.  Use the Close call to close all such file handles before re-creating the file.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs36 Open\tab -\tab Opcode 2\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 int\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 NVM_Bios(2, file_name)\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\tab \tab \f5648 int\tab \tab opcode = 2;\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 \tab \tab \tab \tab \f5648 char\tab \tab *file_name;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Assembly\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\tab \tab \f5648 4(sp)\tab \tab #2\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab 6(sp)\tab \tab file_name\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Returns:\tab \tab \tab \f5648 A non-negative handle on success\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab EFILNF\tab if the application has no file with the given\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab \tab \tab name\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Purpose:\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 Instructs the Bios to attempt to access the blocks of memory owned by the current application (as set in Initialize) and whose file name is \f5649 file_name.\f5648   \f5649 File_name \f5648 must point to a null terminated file name string of an existing file.  As with the Create call, Open will search only for files owned by the current application; it will not open a file owned by a different application, even if the file names are the same.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 The handle returned by Open must be used in any Read, Write, or Seek calls referring to this file.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs36 Close\tab \tab -\tab Opcode 3\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 int\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 NVM_Bios(3, handle)\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\f5648 \tab \tab int\tab \tab opcode = 3;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab int \tab \tab handle;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Assembly \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\tab \tab \f5648 4(sp)\tab \tab #3\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab 6(sp)\tab \tab handle\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Returns:\tab \tab \tab \f5648 0 on success\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab EIHNDL if passed an invalid handle\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Purpose:\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 Used by an application to indicate that it is finished working with a file previously opened by Open or Create.  After the call to Close, the handle passed to close becomes invalid, and no further Read or Write calls on that handle will succeed.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs36 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs36 Delete\tab \tab -\tab Opcode 4\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 int\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 NVM_Bios(4, app_name, file_name)\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\f5648 \tab \tab int\tab \tab opcode = 4;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab char \tab \tab *app_name;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab char\tab \tab *file_name;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Assembly \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\tab \tab \f5648 4(sp)\tab \tab #4\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab 6(sp)\tab \tab app_name\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab 10(sp)\tab \tab file_name\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Returns:\tab \tab \tab \f5648 0 on success\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab EFILNF if no file matching the given application name and file\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab name is found\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Purpose: \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 Deletes a file, freeing the memory associated with it.  Any application may delete any other application's file, by passing in the application name and file name (as determined by Search First and Search Next) in \f5649 app_name\f5648  and \f5649 file_name\f5648  respectively. \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 Note that applications should never delete files belonging to other applications unless specifically requested to do so by the user .  If an application needs more space than is available on the cartridge, then it should tell the user and offer him or her the choice of either aborting the current operation or of selecting one or more files to delete from the cartridge.\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 WARNING:  do not make this call if there is an existing file handle (returned by a previous Create or Open call) referring to the file being deleted.  Use the Close call to close all such file handles before deleting the file.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs36 Read\tab -\tab Opcode 5\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 long\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 NVM_Bios(5, handle,bufptr,count)\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\f5648 \tab \tab int\tab \tab opcode = 5;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab int\tab \tab handle;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab char\tab \tab *bufptr;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab long\tab \tab count;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Assembly\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\tab \tab  \f5648 4(sp)\tab \tab #5\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab  6(sp)\tab \tab handle\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab  8(sp)\tab \tab bufptr\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab 12(sp)\tab \tab count\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Returns:\tab \tab \tab \f5648 number of bytes read in d0, if successful\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 \tab \tab \tab \tab \f5648 EIHNDL if passed an invalid handle\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Purpose:\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 The Read call may be used to fill a buffer pointed to by\f5649  bufptr\f5648  with \f5649 count\f5648  number of bytes from the file whose file handle (returned from a previous Open or Close call) is \f5649 handle\f5648 .  The read will begin at the current position in the file.  This position is initialized to 0 by Open or Create, is incremented by Read and Write (by the number of bytes read or written, respectively), and may be changed by Seek.  The game code must provide a buffer large enough to hold \f5649 count\f5648  number of bytes.   If successful, the call will return the number of bytes read.  At the end of the file (i.e. when the file's current position exceeds its size) 0 bytes will be returned by Read.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs36 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs36 Write\tab -\tab Opcode 6\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 long\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 NVM_Bios(6, handle, bufptr, count)\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\f5648 \tab \tab int\tab \tab opcode = 6;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab int\tab \tab handle;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab char\tab \tab *bufptr;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab long\tab \tab count;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Assembly\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\tab \tab  \f5648 4(sp)\tab \tab #6\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab  6(sp)\tab \tab handle\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab  8(sp)\tab \tab bufptr\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab 12(sp)\tab \tab count\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Returns:\tab \tab \tab \f5648 number of bytes written in d0, if successful\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 \tab \tab \tab \tab \f5648 EIHNDL if passed an invalid handle\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Purpose:\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 The Write call may be used to write \f5649 count \f5648 number of bytes from the buffer pointed to by\f5649  bufptr\f5648  to the file whose file handle (returned from a previous Open or Close call) is \f5649 handle\f5648 .  The write will begin at the current position in the file.  This position is initialized to 0 by Open or Create, is incremented by Read and Write (by the number of bytes read or written, respectively), and may be changed by Seek.  The number of bytes actually written to the file is returned.  This may be less than \f5649 count\f5648  if, for example, an attempt is made to write more bytes to the file than the space allocated for it in Create.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs36 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs36 Search First\tab -\tab Opcode 7\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 int\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 NVM_Bios(7, search_buf, search_flag)\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\f5648 \tab \tab int\tab \tab opcode = 7;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab char\tab \tab *search_buf;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab long\tab \tab search_flag;\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Assembly \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Parameters:\tab \tab  \f5648 4(sp)\tab \tab #7\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab  6(sp)\tab \tab search_buf\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab 10(sp)\tab \tab search_flag\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Returns:\tab \tab \tab \f5648 0 on success\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \tab \tab \tab \tab EFILNF if no files match the search\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Purpose:\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 The Search First call can be used in conjunction with the Search Next call to browse through the backup memory table of contents.  This can be useful for displaying to the user all of the games whose information is backed up on a given cart.  It can also be used by a game to obtain application and file names to be used in the Delete call to make room on a cartridge for its own information.  The game player should be given final authority on this type of action.  \par\pard\ql\fi0\li0\ri731\plain\f5649\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5649\fs24 search_buf\f5648  should point to a word aligned 30 byte buffer.  If the search is successful, the first 4 bytes of this buffer will be filled in with a long word giving the total size of the file.  The next 16 bytes will be filled with a null terminated character string giving the name of the application that created this file; and the final 10 bytes will be filled with a null terminated string consisting of the name the application gave to the file.  These two strings constitute the \f5649 app_name\f5648  and \f5649 file_name\f5648  parameters for the Delete call.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5649\fs24 search_flag\f5648  must be either 0 or 1.  If it is 0, then the search will include all files on the cartridge, regardless of which application created them.  If it is 1, only files created by the current application (as specified by the last call to Initialize) will be included in the search.  The value of \f5649 search_flag\f5648  will be used in subsequent Search Next calls as well.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs36 Search Next\tab -\tab Opcode 8\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 int\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 NVM_Bios(8, search_buf)\par\pard\ql\fi0\li0\ri731\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri683\plain\f5709\fs24 Parameters:\f5648 \tab \tab int\tab \tab opcode = 8;\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab \tab \tab char\tab \tab *search_buf;\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri683\plain\f5709\fs24 Assembly \par\pard\ql\fi0\li0\ri683\plain\f5709\fs24 Parameters:\tab \tab  \f5648 4(sp)\tab \tab #8\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab \tab \tab  6(sp)\tab \tab search_buf\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Returns:\tab \tab \tab \f5648 identical to Search First\par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 \par\pard\ql\fi0\li0\ri731\plain\f5709\fs24 Purpose:\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 To be used in conjunction with Search First to provide the caller with table of contents information.  Call can be made successive times until EFILNF is returned in d0.  This will mean that no other entries exist in backup memory.\par\pard\ql\fi0\li0\ri731\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri683\plain\f5709\fs36 \par\pard\ql\fi0\li0\ri683\plain\f5709\fs36 Seek\tab \tab -\tab Opcode 9\par\pard\ql\fi0\li0\ri683\plain\f5709\fs36 \par\pard\ql\fi0\li0\ri683\plain\f5709\fs28 long\par\pard\ql\fi0\li0\ri683\plain\f5709\fs28 NVM_Bios(9, handle, offset, flag)\par\pard\ql\fi0\li0\ri683\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri636\plain\f5709\fs24 Parameters:\f5648 \tab \tab int\tab \tab opcode = 9;\par\pard\ql\fi0\li0\ri636\plain\f5648\fs24 \tab \tab \tab \tab int\tab \tab handle;\par\pard\ql\fi0\li0\ri636\plain\f5648\fs24 \tab \tab \tab \tab long\tab \tab offset;\par\pard\ql\fi0\li0\ri636\plain\f5648\fs24 \tab \tab \tab \tab int\tab \tab flag;\par\pard\ql\fi0\li0\ri636\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri636\plain\f5709\fs24 Assembly \par\pard\ql\fi0\li0\ri636\plain\f5709\fs24 Parameters:\tab \tab  \f5648 4(sp)\tab \tab #9\par\pard\ql\fi0\li0\ri636\plain\f5648\fs24 \tab \tab \tab \tab  6(sp)\tab \tab handle\par\pard\ql\fi0\li0\ri636\plain\f5648\fs24 \tab \tab \tab \tab  8(sp)\tab \tab offset\par\pard\ql\fi0\li0\ri636\plain\f5648\fs24 \tab \tab \tab \tab 12(sp)\tab \tab flag\par\pard\ql\fi0\li0\ri636\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri683\plain\f5709\fs24 Returns:\tab \tab \tab \f5648 the new file position, if successful\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab \tab \tab EIHNDL if passed an invalid handle\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \tab \tab \tab \tab ERANGE if the offset would be past the end of file\par\pard\ql\fi0\li0\ri683\plain\f5709\fs24 \par\pard\ql\fi0\li0\ri683\plain\f5709\fs24 Purpose:\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 Resets the file position (used by Read and Write) for the file whose file handle (as returned by Open or Create) is \f5649 handle\f5648  to be at \f5649 offset\f5648  bytes from the beginning of the file (if \f5649 flag\f5648  is 0) or from the current position in the file (if \f5649 flag\f5648  is 1).  Subsequent Read or Write calls will begin their operations at this point (and will update the file position as usual). \par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri636\plain\f5709\fs36 \par\pard\ql\fi0\li0\ri636\plain\f5709\fs36 Inquire\tab \tab -\tab Opcode 10\par\pard\ql\fi0\li0\ri636\plain\f5709\fs36 \par\pard\ql\fi0\li0\ri636\plain\f5709\fs28 int\par\pard\ql\fi0\li0\ri636\plain\f5709\fs28 NVM_Bios(10, totspc, freespc)\par\pard\ql\fi0\li0\ri636\plain\f5709\fs28 \par\pard\ql\fi0\li0\ri589\plain\f5709\fs24 Parameters:\f5648 \tab \tab int\tab \tab opcode = 10;\par\pard\ql\fi0\li0\ri589\plain\f5648\fs24 \tab \tab \tab \tab long\tab \tab *totspc;\par\pard\ql\fi0\li0\ri589\plain\f5648\fs24 \tab \tab \tab \tab long\tab \tab *freespc;\par\pard\ql\fi0\li0\ri589\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri589\plain\f5709\fs24 Assembly \par\pard\ql\fi0\li0\ri589\plain\f5709\fs24 Parameters:\tab \tab  \f5648 4(sp)\tab \tab #10\par\pard\ql\fi0\li0\ri589\plain\f5648\fs24 \tab \tab \tab \tab  6(sp)\tab \tab totspc\par\pard\ql\fi0\li0\ri589\plain\f5648\fs24 \tab \tab \tab \tab  8(sp)\tab \tab freespc\par\pard\ql\fi0\li0\ri589\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri636\plain\f5709\fs24 Returns:\tab \tab \tab \f5648 0 on success\par\pard\ql\fi0\li0\ri636\plain\f5648\fs24 \par\pard\ql\fi0\li0\ri683\plain\f5709\fs24 Purpose:\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 Inquires about the amount of space available on the cartridge.  The \f5649 totspc \f5648 parameter points to a long word which is filled in with the total amount of cartridge memory which may be used for applications (i.e. the size of the largest possible memory block, assuming it is the only memory block on the cartridge).  The \f5649 freespc\f5648  parameter points to a long word which is filled in with the amount of cartridge memory currently free (i.e. the size of the largest memory block which could be created at the present time).  (Note that the amount of free memory is not the only constraint on the Create call; even if there is sufficient space for a memory block, Create may return ENOSPC if there is no room left in the cartridge's table of contents.)\par\pard\ql\fi0\li0\ri683\plain\f5648\fs24 \sect}